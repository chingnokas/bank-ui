name: Banking App CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_FRONTEND: chingnokas/cg-bank
  IMAGE_NAME_BACKEND: chingnokas/cg-backbank
  DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}
  KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}

jobs:
  # Detect changes to determine what needs to be built/deployed
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      infrastructure: ${{ steps.changes.outputs.infrastructure }}
      frontend: ${{ steps.changes.outputs.frontend }}
      backend: ${{ steps.changes.outputs.backend }}
      monitoring: ${{ steps.changes.outputs.monitoring }}
      k8s: ${{ steps.changes.outputs.k8s }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            infrastructure:
              - 'infra/**'
              - 'terraform/**'
            frontend:
              - 'frontend/**'
              - 'Dockerfile.frontend'
            backend:
              - 'backend/**'
              - 'Dockerfile.backend'
            monitoring:
              - 'k8s/monitoring/**'
            k8s:
              - 'k8s/**'

  # Infrastructure provisioning with OpenTofu
  provision-infrastructure:
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.infrastructure == 'true' || github.event_name == 'workflow_dispatch'
    outputs:
      cluster-endpoint: ${{ steps.cluster-info.outputs.endpoint }}
      cluster-ca: ${{ steps.cluster-info.outputs.ca-certificate }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: 1.6.0

      - name: Configure DigitalOcean CLI
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_TOKEN }}

      - name: Check DigitalOcean Token
        run: |
          if [ -z "${{ secrets.DIGITALOCEAN_TOKEN }}" ]; then
            echo "âŒ DIGITALOCEAN_TOKEN secret is not set"
            echo "Please add your DigitalOcean API token to GitHub secrets"
            echo "Go to: https://github.com/${{ github.repository }}/settings/secrets/actions"
            exit 1
          else
            echo "âœ… DigitalOcean token is configured"
          fi

      - name: Initialize OpenTofu
        working-directory: ./infra
        run: |
          # Use simple configuration for initial deployment
          cp simple.tf main.tf.backup
          mv simple.tf main.tf
          tofu init

      - name: Plan Infrastructure
        working-directory: ./infra
        run: |
          tofu plan -var="do_token=${{ secrets.DIGITALOCEAN_TOKEN }}" \
                    -var="cluster_name=banking-app-k8s" \
                    -var="region=nyc1" \
                    -var="node_count=2" \
                    -out=tfplan

      - name: Apply Infrastructure
        working-directory: ./infra
        if: github.ref == 'refs/heads/main'
        run: |
          tofu apply -auto-approve tfplan

      - name: Get Cluster Info
        id: cluster-info
        if: github.ref == 'refs/heads/main'
        run: |
          doctl kubernetes cluster kubeconfig save banking-app-k8s
          echo "endpoint=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')" >> $GITHUB_OUTPUT
          echo "ca-certificate=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[0].cluster.certificate-authority-data}')" >> $GITHUB_OUTPUT

  # Wait for infrastructure to be ready
  verify-infrastructure:
    runs-on: ubuntu-latest
    needs: [detect-changes, provision-infrastructure]
    if: always() && (needs.provision-infrastructure.result == 'success' || needs.detect-changes.outputs.infrastructure == 'false')
    steps:
      - name: Configure kubectl
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG_DATA }}" | base64 -d > ~/.kube/config

      - name: Verify cluster connectivity
        run: |
          kubectl cluster-info
          kubectl get nodes
          
      - name: Wait for cluster to be ready
        run: |
          kubectl wait --for=condition=Ready nodes --all --timeout=300s

  # Build and push Docker images
  build-images:
    runs-on: ubuntu-latest
    needs: [detect-changes, verify-infrastructure]
    if: needs.detect-changes.outputs.frontend == 'true' || needs.detect-changes.outputs.backend == 'true'
    strategy:
      matrix:
        include:
          - component: frontend
            dockerfile: frontend/Dockerfile
            context: frontend
            image: ${{ env.IMAGE_NAME_FRONTEND }}
            condition: ${{ needs.detect-changes.outputs.frontend == 'true' }}
          - component: backend
            dockerfile: backend/Dockerfile
            context: backend
            image: ${{ env.IMAGE_NAME_BACKEND }}
            condition: ${{ needs.detect-changes.outputs.backend == 'true' }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        if: matrix.condition == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        if: matrix.condition == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        if: matrix.condition == 'true'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ matrix.image }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        if: matrix.condition == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

  # Deploy monitoring stack
  deploy-monitoring:
    runs-on: ubuntu-latest
    needs: [detect-changes, verify-infrastructure]
    if: needs.detect-changes.outputs.monitoring == 'true' || github.event_name == 'workflow_dispatch'
    steps:
      - uses: actions/checkout@v4

      - name: Configure kubectl
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG_DATA }}" | base64 -d > ~/.kube/config

      - name: Deploy Prometheus
        run: |
          kubectl apply -f k8s/monitoring/prometheus/
          kubectl rollout status deployment/prometheus-server -n monitoring --timeout=300s

      - name: Deploy Grafana
        run: |
          kubectl apply -f k8s/monitoring/grafana/
          kubectl rollout status deployment/grafana -n monitoring --timeout=300s

      - name: Configure Grafana Dashboards
        run: |
          kubectl apply -f k8s/monitoring/dashboards/

  # Deploy Argo CD and configure applications
  deploy-argocd:
    runs-on: ubuntu-latest
    needs: [verify-infrastructure, build-images]
    if: always() && needs.verify-infrastructure.result == 'success'
    steps:
      - uses: actions/checkout@v4

      - name: Configure kubectl
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG_DATA }}" | base64 -d > ~/.kube/config

      - name: Create Application Secrets
        run: |
          # Create namespaces
          kubectl apply -f k8s/namespace.yaml

          # Apply application secrets (without sensitive data)
          kubectl apply -f k8s/secrets/banking-secrets.yaml

          # Create registry secret for pulling images
          kubectl create secret docker-registry registry-credentials \
            --docker-server=${{ env.REGISTRY }} \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.GITHUB_TOKEN }} \
            --namespace=banking-app \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Install Argo CD
        run: |
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          kubectl rollout status deployment/argocd-server -n argocd --timeout=300s

      - name: Configure Argo CD Applications
        run: |
          kubectl apply -f k8s/argocd/

      - name: Wait for Argo CD sync
        run: |
          # Install Argo CD CLI
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
          
          # Get Argo CD admin password
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          
          # Port forward and login
          kubectl port-forward svc/argocd-server -n argocd 8080:443 &
          sleep 10
          argocd login localhost:8080 --username admin --password $ARGOCD_PASSWORD --insecure
          
          # Sync applications if app code changed
          if [[ "${{ needs.detect-changes.outputs.frontend }}" == "true" || "${{ needs.detect-changes.outputs.backend }}" == "true" ]]; then
            argocd app sync banking-app-frontend --timeout 300
            argocd app sync banking-app-backend --timeout 300
            argocd app wait banking-app-frontend --timeout 300
            argocd app wait banking-app-backend --timeout 300
          fi

  # Health checks and notifications
  post-deployment-checks:
    runs-on: ubuntu-latest
    needs: [deploy-argocd, deploy-monitoring]
    if: always()
    steps:
      - name: Configure kubectl
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG_DATA }}" | base64 -d > ~/.kube/config

      - name: Health Check - Frontend
        run: |
          kubectl wait --for=condition=available deployment/banking-frontend -n banking-app --timeout=300s
          FRONTEND_URL=$(kubectl get svc banking-frontend -n banking-app -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          curl -f http://$FRONTEND_URL/ || exit 1

      - name: Health Check - Backend
        run: |
          kubectl wait --for=condition=available deployment/banking-backend -n banking-app --timeout=300s
          BACKEND_URL=$(kubectl get svc banking-backend -n banking-app -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          curl -f http://$BACKEND_URL:8000/api/ || exit 1

      - name: Health Check - Database
        run: |
          kubectl wait --for=condition=ready pod -l app=postgres -n banking-app --timeout=300s

      - name: Health Check - Monitoring
        run: |
          kubectl wait --for=condition=available deployment/prometheus-server -n monitoring --timeout=300s
          kubectl wait --for=condition=available deployment/grafana -n monitoring --timeout=300s

      - name: Get Service URLs
        run: |
          echo "## ðŸš€ Deployment Complete!" >> $GITHUB_STEP_SUMMARY
          echo "### Service URLs:" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend**: http://$(kubectl get svc banking-frontend -n banking-app -o jsonpath='{.status.loadBalancer.ingress[0].ip}')/" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend API**: http://$(kubectl get svc banking-backend -n banking-app -o jsonpath='{.status.loadBalancer.ingress[0].ip}'):8000/" >> $GITHUB_STEP_SUMMARY
          echo "- **Grafana**: http://$(kubectl get svc grafana -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}'):3000/" >> $GITHUB_STEP_SUMMARY
          echo "- **Prometheus**: http://$(kubectl get svc prometheus-server -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}'):9090/" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ” Access Credentials:" >> $GITHUB_STEP_SUMMARY
          echo "- **Grafana**: admin / BankingGrafana2024!" >> $GITHUB_STEP_SUMMARY
          echo "- **Argo CD**: admin / \$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\"{.data.password}\" | base64 -d)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Monitoring:" >> $GITHUB_STEP_SUMMARY
          echo "- Application metrics available in Grafana" >> $GITHUB_STEP_SUMMARY
          echo "- Alerts configured for critical services" >> $GITHUB_STEP_SUMMARY
          echo "- Database performance monitoring enabled" >> $GITHUB_STEP_SUMMARY
